<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>論理回路ドラッグ教材｜フリーモード＋クイズ</title>
<style>
  :root{ --neon:#ccff00; --hatch:#ef4444; --grid:#e5e7eb; }
  *{box-sizing:border-box}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif;background:#0b1220;color:#e5e7eb}
  header{display:flex;gap:8px;align-items:center;padding:10px 12px;border-bottom:1px solid #1f2937}
  h1{margin:0 8px 0 0;font-size:15px;font-weight:800}
  .spacer{flex:1}
  .btn{appearance:none;border:1px solid #374151;background:#0b1324;color:#e5e7eb;padding:8px 10px;border-radius:10px;cursor:pointer;font-weight:700;font-size:12px}
  .btn.primary{background:#1e293b;border-color:#475569}
  .btn.good{background:#052e16;border-color:#14532d}
  .btn.toggle.active{background:var(--neon);border-color:var(--neon);color:#111827}
  .btn.mode{padding:10px 20px;font-size:14px;border-radius:9999px;min-width:160px;display:inline-flex;align-items:center;justify-content:center;line-height:1}
  .btn.quiz.active{background:var(--neon);border-color:var(--neon);color:#111827}

  .layout{display:grid;grid-template-columns:260px 1fr 340px;height:calc(100vh - 56px)}
  /* 左パレット */
  #palette{background:#111827;border-right:1px solid #1f2937;padding:12px;overflow:auto}
  .item{display:flex;align-items:center;gap:8px;padding:9px;border:1px dashed #374151;border-radius:10px;margin-bottom:8px;cursor:grab;background:#0b1324;user-select:none}
  .xgate{background:#1f2937;width:32px;height:20px;border-radius:6px;border:1px solid #475569}

  /* 中央キャンバス */
  #stage-wrap{position:relative;background:
    repeating-linear-gradient(0deg,var(--grid) 0,var(--grid) 1px,transparent 1px,transparent 24px),
    repeating-linear-gradient(90deg,var(--grid) 0,var(--grid) 1px,transparent 1px,transparent 24px),
    #ffffff}
  #stage{position:relative;width:100%;height:100%;z-index:2}
  #wires{position:absolute;inset:0;width:100%;height:100%;z-index:1;overflow:visible}
  #wires path{pointer-events:stroke;stroke:#60a5fa;stroke-width:4;fill:none;opacity:.95;filter:drop-shadow(0 0 2px rgba(96,165,250,.7))}
  #wires path.selected{stroke:var(--neon);stroke-width:5;opacity:1;filter:drop-shadow(0 0 4px rgba(204,255,0,.6))}
  .hint{position:absolute;top:10px;left:12px;background:rgba(2,6,23,.72);border:1px solid #0b1220;backdrop-filter:blur(6px);padding:8px 10px;border-radius:10px;font-size:12px;color:#cbd5e1;max-width:min(860px,85vw);z-index:3}

  .node{position:absolute;min-width:96px;background:#0b1324;border:1px solid #384152;border-radius:14px;box-shadow:0 10px 25px rgba(0,0,0,.3);user-select:none;z-index:2}
  .node.selected{outline:2px solid #6366f1}
  .node .head{padding:6px 10px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,0));border-bottom:2px solid var(--neon);border-top-left-radius:14px;border-top-right-radius:14px;font-weight:800;font-size:13px;display:flex;align-items:center;justify-content:space-between;cursor:move}
  .node .body{padding:8px 10px 10px;display:flex;gap:8px;align-items:center}
  .pins{display:flex;flex-direction:column;gap:8px}
  .pin{width:14px;height:14px;border-radius:50%;border:2px solid #0f172a;box-shadow:0 0 0 2px #0b1220;background:#ffffff;cursor:pointer}
  .pin.out{background:#ffffff;border-color:#0f172a}
  .pin.hot{outline:2px solid #60a5fa}
  .pin.linked{outline:2px solid #0ea5e9;background:#ffffff}
  .gate-label{font-weight:800;letter-spacing:.05em;font-size:12px;color:#e2e8f0;padding:2px 6px;border-radius:6px;border:1px solid #374151}

  .toggle{width:46px;height:26px;background:#111827;border:1px solid #374151;border-radius:999px;position:relative;cursor:pointer}
  .knob{position:absolute;top:2px;left:2px;width:22px;height:22px;background:#1f2937;border:2px solid #ffffff;border-radius:999px;box-shadow:0 1px 2px rgba(0,0,0,.35);transition:left .15s ease, background-color .15s ease}
  .toggle.on .knob{left:22px;background:#ff7eb6}

  .led{width:18px;height:18px;border-radius:50%;background:#1f2937;border:2px solid #0b1220;box-shadow:inset 0 0 14px rgba(0,0,0,.5)}
  .led.on{background:radial-gradient(circle at 50% 35%,#ff6d6d,#b91c1c 60%,#7f1d1d);box-shadow:0 0 18px rgba(239,68,68,.55),inset 0 0 10px rgba(255,255,255,.25)}

  /* 右パネル */
  #viz{background:#111827;border-left:1px solid #1f2937;padding:12px;overflow:auto}
  #viz .cap{font-size:12px;color:#cbd5e1;margin-top:8px}
  #venn{display:block;margin:6px auto 0;background:#0b1324;border:1px dashed #374151;border-radius:10px}
  #guide{margin-top:14px}
  #guide h2{font-size:13px;margin:0 0 8px;color:#9ca3af}
  .guide-grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .gcard{background:#0b1324;border:1px solid #374151;border-radius:10px;padding:8px}
  .gcap{font-size:12px;color:#cbd5e1;margin-top:6px}
  .gcan{display:block;margin:0 auto;border:1px dashed #374151;border-radius:8px}

  footer{height:40px;display:flex;align-items:center;justify-content:space-between;gap:10px;padding:6px 12px;border-top:1px solid #1f2937;background:#0b1220;font-size:12px;color:#cbd5e1}
  #quizBar{display:none;gap:6px;flex-wrap:wrap}
</style>
</head>
<body>
<header>
  <h1>論理回路ドラッグ教材</h1>
  <button class="btn toggle mode active" id="btnModeFree">フリーモード</button>
  <button class="btn toggle mode" id="btnModeQuiz">クイズ</button>
  <div class="spacer"></div>
  <div id="quizBar">
    <button class="btn quiz" data-quiz="1">1</button>
    <button class="btn quiz" data-quiz="2">2</button>
    <button class="btn quiz" data-quiz="3">3</button>
    <button class="btn quiz" data-quiz="4">4</button>
    <button class="btn quiz" data-quiz="5">5</button>
    <button class="btn quiz" data-quiz="6">6</button>
    <button class="btn quiz" data-quiz="7">7</button>
    <button class="btn quiz" data-quiz="8">8</button>
    <button class="btn good" id="btnCheck">判定</button>
  </div>
  <button class="btn" id="btnReset">リセット</button>
  <button class="btn" id="btnExport">エクスポート</button>
  <button class="btn" id="btnImport">インポート</button>
</header>
<div class="layout">
  <aside id="palette">
    <div style="font-size:13px;color:#9ca3af;margin:8px 0 6px">パレット（ドラッグしてキャンバスへ）</div>
    <div class="item" draggable="true" data-type="toggle"><div class="xgate"></div>トグル</div>
    <div class="item" draggable="true" data-type="led"><div class="xgate"></div>LED</div>
    <div class="item" draggable="true" data-type="NOT"><div class="xgate"></div>NOT</div>
    <div class="item" draggable="true" data-type="OR"><div class="xgate"></div>OR</div>
    <div class="item" draggable="true" data-type="AND"><div class="xgate"></div>AND</div>
    <div class="item" draggable="true" data-type="XOR"><div class="xgate"></div>XOR</div>
    <div class="item" draggable="true" data-type="NAND"><div class="xgate"></div>NAND</div>
    <div style="margin-top:10px;color:#9ca3af;font-size:12px;line-height:1.6">
      <b>配線</b> 出力ピン（右）→入力ピン（左）の順にクリック。<br>
      <b>削除</b> ノード選択→Delete/Backspace。配線はクリックで選択→Delete/Backspace、またはダブルクリック。<br>
      <b>移動</b> ノード上部バーをドラッグ（ESCで接続キャンセル）。<br>
      <b>クリック追加</b> パレットをクリックでも中央に追加されます。
    </div>
  </aside>
  <main id="stage-wrap">
    <div id="stage"></div>
    <svg id="wires"></svg>
    <div id="hint" class="hint">フリーモード：A/B/C のトグルを配線して LED（ラベルは Out 推奨）へつなぐと、右上にベン図（赤い斜線）で出力領域を描きます。LEDが複数ある場合は上下2分割で表示。クイズに切り替えると、期待領域（黄緑）とあなたの回路（赤ハッチ）を重ねて判定できます。</div>
  </main>
  <aside id="viz">
    <div style="font-size:13px;color:#9ca3af;margin:8px 0 6px">ベン図（Out=1の領域）</div>
    <canvas id="venn" width="280" height="280"></canvas>
    <div id="vennCaption" class="cap">LEDを接続するとベン図に斜線で表示します（フリーモード）</div>

    <div id="guide">
      <h2>素子ガイド（Venn 図で見る Out=1 の領域）</h2>
      <div class="guide-grid">
        <div class="gcard"><canvas id="gAND" class="gcan" width="150" height="120"></canvas><div class="gcap">AND：両方1のところ</div></div>
        <div class="gcard"><canvas id="gOR" class="gcan" width="150" height="120"></canvas><div class="gcap">OR：どちらか1のところ</div></div>
        <div class="gcard"><canvas id="gXOR" class="gcan" width="150" height="120"></canvas><div class="gcap">XOR：ちょうど1つのところ</div></div>
        <div class="gcard"><canvas id="gNAND" class="gcan" width="150" height="120"></canvas><div class="gcap">NAND：ANDの反対（交わり以外）</div></div>
        <div class="gcard" style="grid-column:1 / span 2"><canvas id="gNOT" class="gcan" width="310" height="120"></canvas><div class="gcap">NOT：Aが0のところ（Aの外側）</div></div>
      </div>
    </div>
  </aside>
</div>
<footer>
  <div id="status">ノード: 0 / 配線: 0</div>
  <div id="quizTitle">クイズ：未選択</div>
</footer>
<script>
(()=>{
  // ====== モード管理 ======
  let mode='free'; // 'free' | 'quiz'
  const btnModeFree=document.getElementById('btnModeFree');
  const btnModeQuiz=document.getElementById('btnModeQuiz');
  const quizBar=document.getElementById('quizBar');
  const vennCaption=document.getElementById('vennCaption');
  const quizTitleEl=document.getElementById('quizTitle');
  function setMode(next){
    mode=next; btnModeFree.classList.toggle('active',mode==='free'); btnModeQuiz.classList.toggle('active',mode==='quiz');
    quizBar.style.display = (mode==='quiz')? 'flex' : 'none';
    document.querySelectorAll('.btn.quiz').forEach(b=>b.classList.remove('active'));
    if(mode==='free'){
      quizTitleEl.textContent='クイズ：未選択';
      vennCaption.textContent='LEDを接続するとベン図に斜線で表示します（フリーモード）';
      renderVennFree();
    }else{
      vennCaption.textContent='黄緑＝問題の領域 ／ 赤ハッチ＝あなたの回路（LEDにつないだ出力）';
      renderVennById(currentQuizId);
    }
  }
  btnModeFree.addEventListener('click',()=>setMode('free'));
  btnModeQuiz.addEventListener('click',()=>setMode('quiz'));

  // ====== 基本状態 ======
  let NODE_ID=1, WIRE_ID=1;
  const nodes=new Map();
  const wires=new Map();
  const stage=document.getElementById('stage');
  const svg=document.getElementById('wires');
  const wrap=document.getElementById('stage-wrap');
  const statusEl=document.getElementById('status');
  const hintEl=document.getElementById('hint');
  let selectedWireId=null, dropLock=false;

  function updateStatus(){ statusEl.textContent=`ノード: ${nodes.size} / 配線: ${wires.size}`; }

  // ====== ノード生成・UI ======
  function nodeEl({id,x,y,label}){
    const el=document.createElement('div'); el.className='node'; el.style.left=x+'px'; el.style.top=y+'px'; el.dataset.id=id;
    el.innerHTML=`<div class="head"><span>${label||''}</span><span class="pill">#${id}</span></div><div class="body"></div>`;
    stage.appendChild(el); enableDrag(el); el.addEventListener('mousedown',()=>selectNode(el)); return el;
  }
  function enableDrag(el){
    const head=el.querySelector('.head');
    let ox=0,oy=0,dragging=false,pid=null;
    function onMove(e){ if(!dragging) return; const r=stage.getBoundingClientRect(); const nx=e.clientX-r.left-ox; const ny=e.clientY-r.top-oy; el.style.left=Math.max(10,Math.round(nx))+'px'; el.style.top=Math.max(10,Math.round(ny))+'px'; redrawWires(); }
    function onUp(){ if(pid!==null){ try{el.releasePointerCapture(pid);}catch{} pid=null; } dragging=false; window.removeEventListener('pointermove',onMove,{passive:false}); window.removeEventListener('pointerup',onUp); window.removeEventListener('pointercancel',onUp); updateStatus(); }
    head.addEventListener('pointerdown',(e)=>{ dragging=true; pid=e.pointerId; try{el.setPointerCapture(pid);}catch{} const r=el.getBoundingClientRect(); ox=e.clientX-r.left; oy=e.clientY-r.top; window.addEventListener('pointermove',onMove,{passive:false}); window.addEventListener('pointerup',onUp); window.addEventListener('pointercancel',onUp); });
  }
  function selectNode(el){ clearWireSelection(); document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected')); el.classList.add('selected'); }
  document.addEventListener('keydown',(e)=>{
    if(e.key==='Delete'||e.key==='Backspace'){
      const sel=document.querySelector('.node.selected'); if(sel){ e.preventDefault(); removeNode(sel.dataset.id); return; }
      if(selectedWireId){ e.preventDefault(); removeWire(selectedWireId); return; }
    }
    if(e.key==='Escape'){ clearPinHighlights(); connectMode={from:null,to:null}; }
  });
  function removeNode(id){ const n=nodes.get(id); if(!n) return; [...wires.values()].forEach(w=>{ if(w.from.id===id||w.to.id===id) removeWire(w.id); }); n.el.remove(); nodes.delete(id); updateStatus(); simulate(); }

  // ====== 配線描画 ======
  function pinCenter(pinEl){ const pr=pinEl.getBoundingClientRect(); const sr=svg.getBoundingClientRect(); return {x: pr.left-sr.left+pr.width/2, y: pr.top-sr.top+pr.height/2}; }
  function bezier(a,b){ const dx=Math.max(40,Math.abs(b.x-a.x)/2); return `M ${a.x} ${a.y} C ${a.x+dx} ${a.y}, ${b.x-dx} ${b.y}, ${b.x} ${b.y}`; }
  function redrawWire(w){ const nf=nodes.get(w.from.id), nt=nodes.get(w.to.id); if(!nf||!nt) return; const pf=nf.outputs[w.from.out].el, pt=nt.inputs[w.to.in].el; const a=pinCenter(pf), b=pinCenter(pt); w.el.setAttribute('d', bezier(a,b)); }
  function redrawWires(){ wires.forEach(redrawWire); }
  function refreshLinkedPins(){ document.querySelectorAll('.pin.linked').forEach(p=>p.classList.remove('linked')); wires.forEach(w=>{ const nf=nodes.get(w.from.id); const nt=nodes.get(w.to.id); if(nf&&nf.outputs[w.from.out]) nf.outputs[w.from.out].el.classList.add('linked'); if(nt&&nt.inputs[w.to.in]) nt.inputs[w.to.in].el.classList.add('linked'); }); }
  function clearWireSelection(){ document.querySelectorAll('#wires path.selected').forEach(p=>p.classList.remove('selected')); selectedWireId=null; }
  function selectWire(id){ clearWireSelection(); const w=wires.get(id); if(!w) return; w.el.classList.add('selected'); selectedWireId=id; document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected')); }
  function addWire(from,to){ const id=(WIRE_ID++).toString(); const path=document.createElementNS('http://www.w3.org/2000/svg','path'); path.dataset.id=id; svg.appendChild(path); const w={id,el:path,from:{id:from.nodeId,out:from.outIndex},to:{id:to.nodeId,in:to.inIndex}}; wires.set(id,w); path.addEventListener('click',e=>{ selectWire(id); e.stopPropagation(); }); path.addEventListener('dblclick',e=>{ removeWire(id); e.stopPropagation(); }); redrawWire(w); refreshLinkedPins(); updateStatus(); simulate(); }
  function removeWire(id){ const w=wires.get(id); if(!w) return; w.el.remove(); wires.delete(id); refreshLinkedPins(); clearWireSelection(); updateStatus(); simulate(); }

  // ====== ノード種類 ======
  function nextToggleLabel(){ const order=['A','B','C']; const used=new Set(); nodes.forEach(n=>{ if(n.type==='toggle'){ const t=n.el.querySelector('.head span').textContent.trim(); if(order.includes(t)) used.add(t); }}); for(const s of order){ if(!used.has(s)) return s; } const extra=['D','E','F','G']; return extra[(Math.random()*extra.length)|0]; }

  function addNode(type,x,y,opts={}){
    const id=(NODE_ID++).toString(); const base={id,type,x,y,label:opts.label||type,inputs:[],outputs:[],value:false}; const el=nodeEl({id,x,y,label:opts.label||type}); base.el=el; const body=el.querySelector('.body');
    function makeIn(){ const p=document.createElement('div'); p.className='pin in'; return p; }
    function makeOut(){ const p=document.createElement('div'); p.className='pin out'; return p; }
    if(type==='toggle'){
      el.querySelector('.head span').textContent=opts.label||nextToggleLabel();
      const left=document.createElement('div'); left.className='pins'; body.appendChild(left);
      const toggle=document.createElement('div'); toggle.className='toggle'; body.appendChild(toggle);
      const knob=document.createElement('div'); knob.className='knob'; toggle.appendChild(knob);
      const right=document.createElement('div'); right.className='pins'; body.appendChild(right);
      const out=makeOut(); right.appendChild(out); base.outputs.push({el:out}); base.value=!!opts.init; const render=()=>{ toggle.classList.toggle('on',!!base.value); }; toggle.addEventListener('click',()=>{ base.value=!base.value; render(); simulate(); }); render();
    } else if(type==='led'){
      el.querySelector('.head span').textContent=opts.label||'Out';
      const left=document.createElement('div'); left.className='pins'; body.appendChild(left);
      const led=document.createElement('div'); led.className='led'; body.appendChild(led);
      const inp=makeIn(); left.appendChild(inp); base.inputs.push({el:inp}); base.ledEl=led; base.value=false;
    } else {
      const left=document.createElement('div'); left.className='pins'; body.appendChild(left);
      const label=document.createElement('div'); label.className='gate-label'; label.textContent=type; body.appendChild(label);
      const right=document.createElement('div'); right.className='pins'; body.appendChild(right);
      const nin=(type==='NOT')?1:2; for(let i=0;i<nin;i++){ const ip=makeIn(); left.appendChild(ip); base.inputs.push({el:ip}); } const op=makeOut(); right.appendChild(op); base.outputs.push({el:op});
    }
    nodes.set(id,base); setupPinEvents(base); updateStatus(); simulate(); return base;
  }

  // ====== 接続ロジック ======
  let connectMode={from:null,to:null};
  function setupPinEvents(node){
    node.outputs.forEach((p,idx)=>{ p.el.addEventListener('click',()=>{ if(connectMode.to){ addWire({nodeId:node.id,outIndex:idx},connectMode.to); clearPinHighlights(); connectMode={from:null,to:null}; return; } clearPinHighlights(); connectMode.from={nodeId:node.id,outIndex:idx}; p.el.classList.add('hot'); }); });
    node.inputs.forEach((p,idx)=>{ p.el.addEventListener('click',()=>{ if(connectMode.from){ addWire(connectMode.from,{nodeId:node.id,inIndex:idx}); clearPinHighlights(); connectMode={from:null,to:null}; } else { clearPinHighlights(); connectMode.to={nodeId:node.id,inIndex:idx}; p.el.classList.add('hot'); } }); });
  }
  function clearPinHighlights(){ document.querySelectorAll('.pin.hot').forEach(p=>p.classList.remove('hot')); }

  // ====== 真理値計算 ======
  function inVal(node,i){ for(const w of wires.values()){ if(w.to.id===node.id && w.to.in===i){ const src=nodes.get(w.from.id); return !!src.value; } } return false; }
  function compute(node){ switch(node.type){ case 'toggle': return !!node.value; case 'led': return !!inVal(node,0); case 'NOT': return !inVal(node,0); case 'AND': return inVal(node,0)&&inVal(node,1); case 'OR': return inVal(node,0)||inVal(node,1); case 'XOR': return !!(inVal(node,0)^inVal(node,1)); case 'NAND': return !(inVal(node,0)&&inVal(node,1)); default: return false; } }
  function simulate(){ let changed=true,guard=0; while(changed&&guard<32){ changed=false; guard++; nodes.forEach(n=>{ const v=compute(n); if(n.value!==v){ n.value=v; changed=true; } }); } nodes.forEach(n=>{ if(n.type==='led'){ n.ledEl.classList.toggle('on',!!n.value); } }); if(mode==='free'){ renderVennFree(); } else { renderVennById(currentQuizId); } }

  // ====== DnD ======
  document.querySelectorAll('#palette .item').forEach(it=>{
    it.setAttribute('draggable','true');
    it.addEventListener('dragstart',(e)=>{ const t=it.dataset.type; e.dataTransfer.setData('text/plain', t); e.dataTransfer.effectAllowed='copy'; });
    it.addEventListener('click',()=>{ const r=stage.getBoundingClientRect(); addNode(it.dataset.type, r.width/2-60, r.height/2-20, {}); });
  });
  function getDropPos(e){ const r=stage.getBoundingClientRect(); return { x:e.clientX-r.left-60, y:e.clientY-r.top-20 }; }
  function handleDrop(e){ e.preventDefault(); e.stopPropagation(); const type=e.dataTransfer.getData('text/plain'); if(!type) return; const pos=getDropPos(e); addNode(type,pos.x,pos.y,{}); }
  wrap.addEventListener('dragover',(e)=>{ e.preventDefault(); });
  wrap.addEventListener('drop',(e)=>{ if(dropLock) return; dropLock=true; handleDrop(e); setTimeout(()=>dropLock=false,0); });
  wrap.addEventListener('mousedown',(e)=>{ if(e.target===wrap || e.target===stage || e.target===svg){ document.querySelectorAll('.node.selected').forEach(n=>n.classList.remove('selected')); clearWireSelection(); } });

  // ====== エクスポート/インポート ======
  function exportJSON(){ return JSON.stringify({ nodes:[...nodes.values()].map(n=>({id:n.id,type:n.type,x:parseInt(n.el.style.left),y:parseInt(n.el.style.top),label:n.el.querySelector('.head span').textContent,value:n.type==='toggle'?!!n.value:undefined})), wires:[...wires.values()].map(w=>({id:w.id,from:w.from,to:w.to})) }, null, 2); }
  function importJSON(json){ const data=JSON.parse(json); clearAll(); const idMap=new Map(); data.nodes.forEach(n=>{ const obj=addNode(n.type,n.x,n.y,{label:n.label,init:n.value}); idMap.set(n.id,obj.id); }); data.wires.forEach(w=>{ addWire({nodeId:idMap.get(w.from.id),outIndex:w.from.out},{nodeId:idMap.get(w.to.id),inIndex:w.to.in}); }); simulate(); }
  function clearAll(){ nodes.forEach(n=>n.el.remove()); nodes.clear(); wires.forEach(w=>w.el.remove()); wires.clear(); clearWireSelection(); updateStatus(); simulate(); }
  document.getElementById('btnExport').addEventListener('click',()=>{ const blob=new Blob([exportJSON()],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='circuit.json'; a.click(); });
  document.getElementById('btnImport').addEventListener('click',()=>{ const inp=document.createElement('input'); inp.type='file'; inp.accept='.json,application/json'; inp.onchange=()=>{ const f=inp.files[0]; const r=new FileReader(); r.onload=()=>importJSON(r.result); r.readAsText(f); }; inp.click(); });
  document.getElementById('btnReset').addEventListener('click',()=>{ clearAll(); if(mode==='free'){ vennCaption.textContent='LEDを接続するとベン図に斜線で表示します（フリーモード）'; } else { quizTitleEl.textContent='クイズ：未選択'; } drawVenn({vars:2, fn:()=>false}, venn, null); drawGuideAll(); });

  // ====== クイズ定義 ======
  const quizzes={
    1:{ title:'Q1：同じなら1（AとBが等しい）', explain:'AとBが同じときOut=1、違うときOut=0。推奨 ≤ 2', rec:2, vars:2, spec:(a,b)=> (a===b) },
    2:{ title:'Q2：1つだけ1なら1', explain:'AとBのうち1つだけが1のときOut=1、それ以外は0。推奨 ≤ 1', rec:1, vars:2, spec:(a,b)=> ((a^b)===1) },
    3:{ title:'Q3：両方1のときだけ0', explain:'AとBが両方1ならOut=0、それ以外はOut=1。推奨 ≤ 1', rec:1, vars:2, spec:(a,b)=> !(a&&b) },
    4:{ title:'Q4：A=1かつB=0で1', explain:'Aが1でBが0のときOut=1、それ以外は0。推奨 ≤ 2', rec:2, vars:2, spec:(a,b)=> (a && !b) },
    5:{ title:'Q5：C=1のときだけ(AまたはB)で1', explain:'C=1のときだけ、AまたはBが1ならOut=1。C=0なら必ず0。推奨 ≤ 2', rec:2, vars:3, spec:(a,b,c)=> (c && (a||b)) },
    6:{ title:'Q6：AとBが違い かつ C=1で1', explain:'AとBが違う（どちらか一方だけ1）かつC=1のときOut=1。推奨 ≤ 2', rec:2, vars:3, spec:(a,b,c)=> (c && ((a^b)===1)) },
    7:{ title:'Q7：どちらかが1なら0', explain:'AまたはBのどちらかでも1ならOut=0、両方0のときだけOut=1。推奨 ≤ 2', rec:2, vars:2, spec:(a,b)=> !(a||b) },
    8:{ title:'Q8：ONの数が偶数なら1（A,B,C）', explain:'A,B,Cのうち1の数が偶数（0または2）ならOut=1、奇数なら0。推奨 ≤ 3', rec:3, vars:3, spec:(a,b,c)=> ((a^b^c)===0) }
  };
  let currentQuizId=null;

  function f(label){ for(const n of nodes.values()){ if(n.el.querySelector('.head span').textContent.trim()===label) return n; } return null; }
  function truthCheck(toggles, leds, fn){ const save=toggles.map(t=>!!t.value); let ok=true, firstErr=null; const N=toggles.length; for(let m=0;m<(1<<N);m++){ for(let i=0;i<N;i++){ toggles[i].value=!!((m>>i)&1); } simulate(); const inVals=toggles.map(t=>!!t.value); const exp=!!fn(...inVals.map(v=>v?1:0)); const act=!!leds[0].value; if(act!==exp && ok){ ok=false; firstErr={inVals,exp,act}; } } save.forEach((v,i)=>{ toggles[i].value=v; }); simulate(); if(ok) return {ok:true,msg:'合格！すべて正しい出力です。'}; const bits=firstErr.inVals.map(v=>v?1:0).join(''); return {ok:false,msg:`不合格：入力(${bits})で 期待=${firstErr.exp?1:0} / 実際=${firstErr.act?1:0}`}; }

  document.querySelectorAll('.btn.quiz').forEach(btn=>btn.addEventListener('click',()=>{
    if(mode!=='quiz') setMode('quiz');
    // ★ クイズ番号を押したら、いままで置いた素子をリセット
    clearAll();
    document.querySelectorAll('.btn.quiz').forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    currentQuizId=btn.getAttribute('data-quiz');
    const q=quizzes[currentQuizId];
    quizTitleEl.textContent=q.title; hintEl.textContent=q.explain + `（推奨ゲート≤${q.rec}）`;
    renderVennById(currentQuizId);
  }));

  document.getElementById('btnCheck').addEventListener('click',()=>{
    if(mode!=='quiz'){ hintEl.textContent='まず「クイズ」タブに切り替えてください。'; return; }
    if(!currentQuizId){ hintEl.textContent='クイズ番号を選んでください。'; return; }
    const q=quizzes[currentQuizId];
    const need=['A','B','C'].slice(0,q.vars);
    const tgs=need.map(l=>f(l));
    const out=f('Out')||f('OUT');
    if(tgs.some(x=>!x)||!out){ hintEl.textContent='A,B(,C) と Out を配置して接続してください。'; return; }
    const res=truthCheck(tgs,[out],q.spec);
    hintEl.textContent=(res.ok?'✅ ':'❌ ')+res.msg;
    renderVennById(currentQuizId); // overlay再計算
  });

  // ====== ベン図描画（共通） ======
  const venn=document.getElementById('venn');
  function getRectsForLEDs(n){ const W=venn.width, H=venn.height; if(n<=1) return [{x:0,y:0,w:W,h:H}]; const gap=10; const hh=(H-gap)/2; return [{x:0,y:0,w:W,h:hh},{x:0,y:hh+gap,w:W,h:hh}]; }

  function drawVenn(spec, canvas, overlay, rect){
    const ctx=canvas.getContext('2d');
    const W=canvas.width, H=canvas.height;
    const rct = rect || {x:0,y:0,w:W,h:H};
    ctx.clearRect(rct.x, rct.y, rct.w, rct.h);
    ctx.save();
    ctx.beginPath(); ctx.rect(rct.x, rct.y, rct.w, rct.h); ctx.clip(); ctx.translate(rct.x, rct.y);
    const w=rct.w, h=rct.h;

    const fillExpect='rgba(204,255,0,0.55)';
    const hatchFill='rgba(239,68,68,0.85)';
    ctx.lineWidth=2; ctx.strokeStyle='#e5e7eb';

    // ---- 共通ジオメトリ
    const gvars = overlay?.vars || spec?.vars || 2;

    // 外周マージン（ベン図が枠からはみ出ないように）
    const shortSide = Math.min(w, h);
    const p = Math.max(6, Math.round(shortSide * 0.06));

    /* ===== 2変数（A,B） ===== */
    // A∩Bを見やすく大きくしつつ、確実に枠内へ収める
    const k2 = 0.80; // 中心間隔 = k2 * r2（小さいほど重なる）
    const r2 = Math.min((w/2 - p) / (1 + k2), (h/2 - p));
    const cx2 = w * 0.5, cy2 = h * 0.5, dx2 = k2 * r2;
    const A2 = { x: cx2 - dx2, y: cy2, r: r2 };
    const B2 = { x: cx2 + dx2, y: cy2, r: r2 };

    /* ===== 3変数（A,B,C） ===== */
    // 写真の構図：A を上、B を左下、C を右下。交差を大きく。
    // A と B/C の中心距離 d = k3 * r3、B/C の水平ずれ dx = a3 * r3、
    // 垂直ずれ vy = sqrt(d^2 - dx^2) から配置を決定。
    const k3 = 0.95;   // d = 0.95 r3（強い交差）
    const a3 = 0.55;   // dx = 0.55 r3
    const vyRatio = Math.sqrt(Math.max(0, k3*k3 - a3*a3));
    // はみ出し防止のため r3 の上限を水平／垂直の両方から算出
    const r3MaxHoriz = (w/2 - p) / (1 + a3);
    const r3MaxVert  = (h - 2*p) / (2 + vyRatio); // Aの半径 + 縦ずれ + B/Cの半径
    const r3 = Math.max(6, Math.min(r3MaxHoriz, r3MaxVert));
    const cx3 = w * 0.5;
    const dx3 = a3 * r3;
    const vy  = vyRatio * r3;
    const yTop = p + r3; // A の中心（上）
    const A3 = { x: cx3,       y: yTop,      r: r3 };
    const B3 = { x: cx3 - dx3, y: yTop + vy, r: r3 };
    const C3 = { x: cx3 + dx3, y: yTop + vy, r: r3 };

    const inside=(pnt,x,y)=>{ const dx=x-pnt.x, dy=y-pnt.y; return (dx*dx+dy*dy)<=pnt.r*pnt.r; };

    function evalSpecAt(s, x, y){
      if(!s) return false;
      if(s.vars===1){ const a=inside(A2,x,y); return s.fn(a?1:0); }
      if(s.vars===2){ const a=inside(A2,x,y), b=inside(B2,x,y); return s.fn(a?1:0,b?1:0); }
      const a=inside(A3,x,y), b=inside(B3,x,y), c=inside(C3,x,y); return s.fn(a?1:0,b?1:0,c?1:0);
    }

    // ---- 塗り（期待=黄緑 / 回路=赤ハッチ）
    const step=1;
    if(spec){ ctx.fillStyle=fillExpect; for(let y=0;y<h;y+=step){ for(let x=0;x<w;x+=step){ if(evalSpecAt(spec,x,y)){ ctx.fillRect(x,y,step,step); } } } }
    if(overlay){ ctx.fillStyle=hatchFill; const period=8, thick=3; for(let y=0;y<h;y+=step){ for(let x=0;x<w;x+=step){ if(evalSpecAt(overlay,x,y) && ((x+y)%period < thick)){ ctx.fillRect(x,y,step,step); } } } }

    // ---- 輪郭
    ctx.fillStyle='#cbd5e1'; ctx.font='12px system-ui';
    if(gvars===1){ ctx.beginPath(); ctx.arc(A2.x,A2.y,A2.r,0,Math.PI*2); ctx.stroke(); ctx.fillText('A', A2.x-6, A2.y-A2.r-6); }
    if(gvars===2){
      ctx.beginPath(); ctx.arc(A2.x,A2.y,A2.r,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(B2.x,B2.y,B2.r,0,Math.PI*2); ctx.stroke();
      ctx.fillText('A', A2.x-6, A2.y-A2.r-6); ctx.fillText('B', B2.x-6, B2.y-B2.r-6);
    }
    if(gvars===3){
      ctx.beginPath(); ctx.arc(A3.x,A3.y,A3.r,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(B3.x,B3.y,B3.r,0,Math.PI*2); ctx.stroke();
      ctx.beginPath(); ctx.arc(C3.x,C3.y,C3.r,0,Math.PI*2); ctx.stroke();
      ctx.fillText('A', A3.x-6, A3.y-A3.r-6);
      ctx.fillText('B', B3.x-6, B3.y-B3.r-6);
      ctx.fillText('C', C3.x-6, C3.y-C3.r-6);
    }
    ctx.restore();
  }

  function findByLabel(label){ for(const n of nodes.values()){ const t=n.el.querySelector('.head span').textContent.trim(); if(t===label) return n; } return null; }
  function listConnectedOutLEDs(){
    const list=[];
    nodes.forEach(n=>{
      if(n.type==='led'){
        const label=n.el.querySelector('.head span').textContent.trim();
        const connected=[...wires.values()].some(w=>w.to.id===n.id);
        if(connected && (label==='Out'||label==='OUT'||label==='Out2')) list.push(n);
      }
    });
    return list;
  }

  // ====== フリーモードのベン図 ======
  function buildOverlayFor(ledNode){
    // A,B,C のみで総当たり評価して LED の真理値を返す
    const toggles=['A','B','C'].map(findByLabel).filter(Boolean);
    const vars=toggles.length; if(vars===0) return {vars:1, fn:()=>false};
    function evalFor(a,b,c){
      const save=toggles.map(t=>t.value);
      const vals=[a,b,c]; toggles.forEach((t,i)=>{ t.value=!!vals[i]; });
      simulateInternal();
      const v=!!ledNode.value;
      toggles.forEach((t,i)=>{ t.value=save[i]; }); simulateInternal();
      return v?1:0;
    }
    return {vars:vars, fn:(a,b,c)=> evalFor(a,b,c)};
  }
  function simulateInternal(){ let changed=true,guard=0; while(changed&&guard<32){ changed=false; guard++; nodes.forEach(n=>{ const v=compute(n); if(n.value!==v){ n.value=v; changed=true; } }); } }

  function renderVennFree(){
    const leds=listConnectedOutLEDs();
    const rects=getRectsForLEDs(leds.length||1);
    const ctx=venn.getContext('2d');
    ctx.clearRect(0,0,venn.width,venn.height);
    if(leds.length===0){ drawVenn({vars:2,fn:()=>false}, venn, null); return; }
    leds.forEach((led,i)=>{ const overlay=buildOverlayFor(led); drawVenn(null, venn, overlay, rects[i]); });
  }

  // ====== クイズのベン図 ======
  function renderVennById(id){
    const leds=listConnectedOutLEDs();
    const rects=getRectsForLEDs(leds.length||1);
    const ctx=venn.getContext('2d');
    ctx.clearRect(0,0,venn.width,venn.height);
    if(!id){ drawVenn({vars:2,fn:()=>false},venn,null); return; }
    const q=quizzes[id]; if(!q){ return; }
    const overlay=(leds[0])? buildOverlayFor(leds[0]) : null;
    drawVenn({vars:q.vars, fn:q.spec}, venn, overlay, rects[0]);
    if(leds.length>1){
      const overlay2=buildOverlayFor(leds[1]);
      drawVenn({vars:q.vars, fn:q.spec}, venn, overlay2, rects[1]);
    }
  }

  // ====== ガイド描画（従来のまま） ======
  function drawGuideAll(){ drawGuideAND(); drawGuideOR(); drawGuideXOR(); drawGuideNAND(); drawGuideNOT(); }
  function gc(id){ return document.getElementById(id).getContext('2d'); }
  function venn2(ctx){ const w=ctx.canvas.width, h=ctx.canvas.height; const aspect=w/h; const r=(aspect>1.4)? Math.min(h*0.33, w*0.22) : Math.min(w,h)*0.24; const A={x:(aspect>1.4? w*0.42 : w*0.37), y:h*0.5, r:r}, B={x:(aspect>1.4? w*0.58 : w*0.63), y:h*0.5, r:r}; return {A,B,w,h}; }
  function venn3(ctx){ const w=ctx.canvas.width, h=ctx.canvas.height; const r=Math.min(w,h)*0.24; const A={x:w*0.37,y:h*0.42,r:r}, B={x:w*0.63,y:h*0.42,r:r}, C={x:w*0.50,y:h*0.72,r:r}; return {A,B,C,w,h}; }
  function fillExpect(ctx, pred){ const w=ctx.canvas.width, h=ctx.canvas.height; const {A,B}=venn2(ctx); const inside=(p,x,y)=>{ const dx=x-p.x, dy=y-p.y; return (dx*dx+dy*dy)<=p.r*p.r; }; ctx.clearRect(0,0,w,h); ctx.lineWidth=2; ctx.strokeStyle='#e5e7eb'; ctx.fillStyle='rgba(204,255,0,0.55)'; for(let y=0;y<h;y+=1){ for(let x=0;x<w;x+=1){ const a=inside(A,x,y), b=inside(B,x,y); if(pred(a?1:0,b?1:0)){ ctx.fillRect(x,y,1,1); } } } ctx.beginPath(); ctx.arc(A.x,A.y,A.r,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.arc(B.x,B.y,B.r,0,Math.PI*2); ctx.stroke(); ctx.fillStyle='#cbd5e1'; ctx.font='12px system-ui'; ctx.fillText('A', A.x-6, A.y-A.r-6); ctx.fillText('B', B.x-6, B.y-B.r-6); }
  function fillExpect3(ctx, pred){ const w=ctx.canvas.width, h=ctx.canvas.height; const {A,B,C}=venn3(ctx); const inside=(p,x,y)=>{ const dx=x-p.x, dy=y-p.y; return (dx*dx+dy*dy)<=p.r*p.r; }; ctx.clearRect(0,0,w,h); ctx.lineWidth=2; ctx.strokeStyle='#e5e7eb'; ctx.fillStyle='rgba(204,255,0,0.55)'; for(let y=0;y<h;y+=1){ for(let x=0;x<w;x+=1){ const a=inside(A,x,y), b=inside(B,x,y), c=inside(C,x,y); if(pred(a?1:0,b?1:0,c?1:0)){ ctx.fillRect(x,y,1,1); } } } [A,B,C].forEach(P=>{ ctx.beginPath(); ctx.arc(P.x,P.y,P.r,0,Math.PI*2); ctx.stroke(); }); ctx.fillStyle='#cbd5e1'; ctx.font='12px system-ui'; ctx.fillText('A', A.x-6, A.y-A.r-6); ctx.fillText('B', B.x-6, B.y-B.r-6); ctx.fillText('C', C.x-6, C.y-C.r-6); }
  function drawGuideAND(){ const ctx=gc('gAND'); fillExpect(ctx, (a,b)=> (a&&b)); }
  function drawGuideOR(){ const ctx=gc('gOR'); fillExpect(ctx, (a,b)=> (a||b)); }
  function drawGuideXOR(){ const ctx=gc('gXOR'); fillExpect(ctx, (a,b)=> ((a^b)===1)); }
  function drawGuideNAND(){ const ctx=gc('gNAND'); fillExpect(ctx, (a,b)=> !(a&&b)); }
  function drawGuideNOT(){ const ctx=gc('gNOT'); const w=ctx.canvas.width, h=ctx.canvas.height; const aspect=w/h; const r=(aspect>1.4)? Math.min(h*0.33, w*0.22) : Math.min(w,h)*0.24; const A={x:(aspect>1.4? w*0.42 : w*0.37), y:h*0.5, r:r}, B={x:(aspect>1.4? w*0.58 : w*0.63), y:h*0.5, r:r}; const inside=(p,x,y)=>{ const dx=x-p.x, dy=y-p.y; return (dx*dx+dy*dy)<=p.r*p.r; }; ctx.clearRect(0,0,w,h); ctx.lineWidth=2; ctx.strokeStyle='#e5e7eb'; ctx.fillStyle='rgba(204,255,0,0.55)'; for(let y=0;y<h;y+=1){ for(let x=0;x<w;x+=1){ const a=inside(A,x,y); if((!a)){ ctx.fillRect(x,y,1,1); } } } ctx.beginPath(); ctx.arc(A.x,A.y,A.r,0,Math.PI*2); ctx.stroke(); ctx.beginPath(); ctx.arc(B.x,B.y,B.r,0,Math.PI*2); ctx.stroke(); ctx.fillStyle='#cbd5e1'; ctx.font='12px system-ui'; ctx.fillText('A', A.x-6, A.y-A.r-6); ctx.fillText('B', B.x-6, B.y-B.r-6); }

  // ====== 初期化 ======
  drawGuideAll();
  drawVenn({vars:2, fn:()=>false}, venn, null);
  setMode('free');
})();
</script>
</body>
</html>
